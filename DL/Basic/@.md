Python 中的 `@`语法（常称**装饰器语法**）是一种强大的元编程工具，用于动态修改函数、方法或类的行为而不改变其原始代码。其主要用途可分为以下四类：

---

### 1. ​**函数/类装饰器（Decorator）​**​

装饰器是 `@`最常见的用途，本质是一个**高阶函数**，接收目标函数作为参数并返回新函数，用于扩展功能（如日志、缓存、权限验证）。

​**核心机制**​：

```python
def decorator(func):          # 接收被装饰函数
    def wrapper(*args, **kwargs):  # 定义新行为
        print("扩展功能")      # 新增逻辑（如执行前操作）
        result = func(*args, **kwargs)  # 调用原函数
        print("扩展功能")      # 新增逻辑（如执行后操作）
        return result
    return wrapper

@decorator  # 等价于 func = decorator(func)
def target_func():
    print("原始功能")
```

​**应用场景**​：

- ​**日志记录**​：自动记录函数调用信息。
    
- ​**性能计时**​：测量函数执行时间。
    
- ​**权限控制**​：验证用户权限后再执行函数。
    
- ​**重复执行**​：通过带参数装饰器实现：
    
    ```python
    def repeat(n):  # 装饰器工厂
        def decorator(func):
            def wrapper(*args, **kwargs):
                for _ in range(n):
                    result = func(*args, **kwargs)
                return result
            return wrapper
        return decorator
    
    @repeat(3)  # 执行3次
    def greet():
        print("Hello!")
    ```
    

---

### 2. ​**矩阵乘法运算符（Python 3.5+）​**​

在科学计算库（如 NumPy、PyTorch）中，`@`被重载为**矩阵乘法运算符**​：

```python
import numpy as np
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])
C = A @ B  # 等价于 np.dot(A, B)
```

输出：

```python
[[19 22]
 [43 50]]
```

---

### 3. ​**类方法修饰符**​

在类定义中，`@`用于声明特殊方法：

- ​**`@staticmethod`**​：定义静态方法，无需实例或类参数：
    
    ```python
    class Math:
        @staticmethod
        def add(a, b):
            return a + b
    print(Math.add(3, 5))  # 8
    ```
    
- ​**`@classmethod`**​：定义类方法，首个参数为类本身（`cls`）：
    
    ```python
    class Example:
        var = "类变量"
        @classmethod
        def update(cls, value):
            cls.var = value
    ```
    
- ​**`@property`**​：将方法转为只读属性，支持 `@属性名.setter`实现写操作：
    
    ```python
    class Circle:
        def __init__(self, radius):
            self._radius = radius
        @property
        def radius(self):         # 访问器
            return self._radius
        @radius.setter
        def radius(self, value):  # 设置器（可加验证）
            if value >= 0: 
                self._radius = value
    ```
    

---

### 4. ​**高级类装饰器**​

`@`可直接修饰类，动态修改类行为（如添加方法、单例模式）：

```python
def class_decorator(cls):
    class NewClass(cls):       # 继承原类
        def new_method(self):  # 新增方法
            print("扩展功能")
    return NewClass

@class_decorator
class MyClass:
    pass
```

---

### ⚠️ ​**常见误区澄清**​

- ​**`@`不是注解（Annotation）​**​：
    
    Python 的类型注解使用 `:`和 `->`（如 `def func(a: int) -> str`），与 `@`无关。
    
- ​**`$`符号在 Python 中无特殊含义**​：
    
    仅在某些库（如正则表达式、Jinja2 模板）中有特定用途，不属于核心语法。
    

---

### ​**总结：`@`的核心用途**​

|类型|作用|典型场景|
|---|---|---|
|函数/类装饰器|扩展函数行为|日志、缓存、权限控制|
|矩阵乘法运算符|计算矩阵乘积|NumPy/PyTorch 运算|
|类方法修饰符|声明静态/类方法、属性|工具类、封装私有变量|
|类装饰器|动态修改类结构|单例模式、添加方法|

> 💡 掌握 `@`语法能显著提升代码的**复用性**与**可读性**，尤其装饰器是 Python 高级编程的核心特性。建议结合 `functools.wraps`保留原函数元信息，避免调试困难。